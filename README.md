# Framework Architecture

Оскільки це Reusable Framework, вся унікальна для геймплею логіка міститься або зв'язана з імплементацією BaseGameplayController. Вся загальна логіка, така як завантаження static data, прогресу гравця, ініціалізація глобальних сервісів та перехід між сценами, знаходиться в стейтах Game State Machine.

## Основні сервіси та системи

### SignalBus

Найпростіша реалізація, що використовує Delegate.Combine та Delegate.Remove для багатоголосної розсилки. Дозволяє повністю розв'язати залежності між системами, роблячи архітектуру гнучкою.

### AppCoordinator

Глобальний сервіс, який слухає сигнали від UI або інших сервісів (наприклад, GameStartRequestedSignal) та викликає зміну станів у Game State Machine. Це дозволяє розділити відповідальність: стейт-машина займається суто логікою переходу між станами, а координатор вирішує, коли саме ці переходи мають відбутися на основі подій у грі.

### Game State Machine

Глобальна стейт-машина гри, яка дає змогу гнучко управляти станами додатка. Вона включає наступні стейти:

* BootstrapState — вхідна точка в гру.
* LoadProgressState — відповідає за завантаження прогресу гравця, конфігів та ініціалізацію глобальних сервісів.
* LoadMetaState — створення та ініціалізація мета-гри (головного меню).
* LoadLevelState — створення та ініціалізація ігрового рівня.
* GameLoopState — початок активного ігрового циклу.
* GameOverState — відповідає за показ екрану виграшу або програшу та іншу логіку, яка стосується завершення гри.

### Asset Provider

Відповідає за асинхронне завантаження асетів через Addressables. Це дозволяє ефективно керувати пам'яттю та завантажувати ресурси тільки тоді, коли вони дійсно потрібні.

### Static Data Service

Відповідає за завантаження конфігів, таких як AdRewardsConfig або LevelConfig. Імплементація через інтерфейс дозволяє легко змінити реалізацію та завантажувати дані з серверу замість локальних ресурсів.

### Persistent Progress Service

Зберігає об'єкт даних гравця (PlayerProgress) в оперативній пам'яті протягом усієї ігрової сесії. Він виступає сполучною ланкою між системою збереження та іншими менеджерами, забезпечуючи доступ до актуального профілю гравця в будь-який момент.

### Save Load Service

Відповідає за серіалізацію даних гравця та їх збереження у локальне сховище (наприклад, через PlayerPrefs). Він працює з інтерфейсами IProgressSaver та IProgressUpdater, що дозволяє автоматично оновлювати або зберігати дані всіх зареєстрованих сервісів.

### Economy Manager

Стандартний менеджер валюти, який відповідає за додавання, віднімання та поточне зберігання значень балансу.

### Analytics Mock

Імітує роботу аналітичних SDK, підтримує виведення параметрів івентів у консоль. Реалізований через інтерфейс, що дозволяє легко тестувати гру та замінити імплементацію на реальну (наприклад, Firebase) в майбутньому.

### Monetization Mock

Імітує показ реклами та дає можливість під'єднати колбеки onSuccess або onFailure в залежності від результату перегляду.

### Reward Service

З'єднує Monetization та Analytics. Ловить сигнал про запит на показ реклами, після чого ініціює показ. Після успішного перегляду видає нагороду відповідно до значень, які підтягуються з конфігу, та виводить відповідні логи в аналітику.

## Геймплейна архітектура

### BaseGameplayController

Абстрактний клас, що відповідає за всі унікальні ігрові механіки та створення рівня. Він виступає в ролі оркестратора для конкретної гри.

## Як додати нову гру

1. Створюємо клас, який наслідується від BaseGameplayController.
2. Додаємо функціонал гри та пов'язуємо його з цим класом (наприклад: створення рівня, специфічні механіки, UI).
3. Створюємо префаб із цим скриптом.
4. Переносимо цей префаб у SceneContext на геймплейній сцені (GameplayScene) у поле GameplayControllerPrefab.

Таким чином реалізація зміниться на нову, і при переході на геймплейну сцену автоматично створиться нова гра.

## Mobile considerations

* Асинхронність: Використання UniTask та Addressables дозволяє уникнути фризів інтерфейсу на мобільних пристроях під час завантаження важких асетів.
* Оптимізація пам'яті: Всі хендли завантажених асетів звільняються при зміні станів або очищенні контролера, що критично для пристроїв з обмеженою оперативною пам'яттю.
* Touch Input: В імплементаціях контролерів варто використовувати Input.GetTouch або нову Input System для коректної обробки натискань на екрані смартфона.

## Що б покращив з більшим часом

* **Object Pooling:** У hybrid-casual іграх часто спавниться багато однотипних об'єктів (монети, частинки, вороги). Власна система пулінгу допомогла б значно знизити навантаження на CPU та зменшити кількість викликів Garbage Collector.
* **Повноцінний UI Manager:** Зараз вікна створюються через фабрики, але додавання менеджера з підтримкою шарів (Layers), черги вікон (Popups Queue) та базових анімацій зробило б систему гнучкішою.
* **Remote Configs:** Інтеграція з Firebase або іншим сервісом для віддаленого керування балансом. Це дозволило б геймдизайнерам змінювати цілі рівнів або розмір нагород у RewardService без перевипуску білда.

